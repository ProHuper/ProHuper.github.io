---
layout:     post
title:      "从一个系列的问题看动态规划的实质"
subtitle:   "妈妈再也不用担心我面试被dp难倒了"
date:       2019-3-4 17:00:00
author:     "Huper"
tags:
    - 算法
---

>场景

日常刷leetcode，今天的题目是：**188.买卖股票的最佳时机 IV**，由于后边有个四，所以肯定是一个系列问题，所以顺便在题库中把所有相关的题都找出来了，这个问题一共有六个变种，并且所有问题都可以用动态规划求解，非常有助于对dp的理解。我们今天就根据这个系列的题目，由浅到深来重新认识一下dp。

在这之前我们先回忆一下动态规划的定义，当初上算法课的时候我们可能会得到这样的定义：

>如果一个问题具有重叠子问题以及最优子结构的话，那么这个问题就可以用动态规划进行求解。

这个定义，说有用很有用，因为它总结得非常准确，一针见血，动态规划问题的确就是这两个特点。但是，仔细想一下这个定义是一个然并卵的定义，它对我们求解问题不会有任何帮助，或者说帮助很少，这就导致了往往我们在遇到一个全新的dp问题时会不知道从何入手。现在我们抛开这个定义，从头说起。先抛出我的观点：

>动态规划是一种自底向上的无重复搜索。

我们知道，计算机求解很多问题的基础原理都是**搜索**，它利用超快的速度将全部的搜索空间覆盖到并进行条件检查，然后返回满足条件的解，我们通常所说的`Brutal Force` 就是这么做，无脑遍历所有解空间。所以面试的时候，当你被问到一个问题，几乎可以很快反应出来一个无脑搜索的方法来，你只需要想到合适的办法构造出所有的解空间就行了，常用的方法有深搜或者多指针。（这里插一句，面试的时候被问到一个问题，很所时候直接想到一个好的解是很难的，所以我们可以先说出暴力解，然后再慢慢优化，这是一种很好的与面试官互动的行为。）

那么怎么优化呢？一般来说，搜索中的优化主要发生在以下两种情况：

>1. 存在重复搜索的解空间（保存已搜索的解空间）
>2. 存在完全没有必要搜索的解空间（剪枝）

情况2，`剪枝`，二分法就是一种剪枝，我们每次都能明确最优解在解空间的某一半中，而放弃解空间的另一半，但是今天我们重点不在这个。现在看情况2，`重复搜索` ，我们在使用递归构造问题的解空间的时候，如果你的递归中含有两个或者以上的递归子式，很容易遇到这种情况，先举一个最经典的重复搜索的例子，求斐波那契数列的第n项：

```c++
int dfs(int n){
    return n <= 2 ? n == 0 ? 0 : 1 : dfs(n - 1) + dfs(n - 2);
}
```

我们画出它的解空间：

![img](https://images2015.cnblogs.com/blog/942946/201605/942946-20160513132025124-1777433900.png)

可以很明显地看到，如果输入是9，在搜索的时候会重复搜索很多节点，比如7就被搜索了两次。为什么会发生这种情况呢？我们现在再来定义一下发生重复搜索的条件：

>递归的时候，如果存在两个或者两个以上的递归子项在同一个表达式中，就会发生重复搜索。（注意必须是在同一个表达式中，比如树的遍历就不会产生重复搜索，树的遍历良定了一种动态规划的模式，因此有了树型dp，文章的最后我稍微提了一下）

这里我说的发生重复搜索条件是指只进行一次输入的情况。对于求n阶乘，它的递归只有一个子项，在一次输入的时候不会发生重复搜索，但是在多次输入的时候就会发生，比如你先求4的阶乘，再求8的阶乘。

好了，在上面我提到，对于重复搜索，解决办法是对已经搜索的解空间结果进行缓存，这也是我们常说的**递归+备忘录** 的方法，也就是动态规划的前身。这个备忘录的形式是多种多样的，但是总体的形式都是`key: value`，一般使用数组或者HashMap实现。事实上，由于**递归+备忘录**的方法中存在一个由上自下的递归表达式，所以我们很多时候都可以将这个表达式的通项公式求出来，从而在O(1)时间内完成问题的求解，比如`斐波那契通项公式` 还有我们熟悉的`卡特兰数`。 but，对于我来说，可能会用O(n^n)的时间去推导通项公式。

说完**递归+备忘录**，我们离动态规划的内涵就更近一步了，我们先总结**递归+备忘录**的实质，然后再变通这个实质。递归本质上是先自顶向下将大规模问题分解成小规模问题，然后再自底向上逐渐求解结果，就是说小规模问题的解构成大规模问题的解。那我们甚至可以不使用递归了，只要能想办法构造问题规模，先构造小规模问题，再构造大规模问题，并不断将已经求解的小规模问题结果保存下来就行了，这样就回到了那个定义：

>动态规划是一种自底向上的无重复搜索。

也就是说，动态规划还是会覆盖到所有的解空间，只不过它避免的重复搜索而已，从这个角度来看，它还是有一定程度的暴力的，因为很多时候我们并不需要覆盖所有的解空间，还需要进行剪枝。比如`leetcode 887`题就是用到了动态规划 + 剪枝。

说完了它的实质，我们来看看如果不用递归，到底怎么构造上面说的小问题和大问题，以下是我自己的总结：

> 1.确定问题的规模空间。
>
> 2.确定问题的状态空间。
>
> 3.确定状态转移公式（如何由小规模问题得到大规模问题）。
>
> 4.自底向上求解问题，一定要由小规模到大规模，每一步都要更新当前规模问题的所有状态。
>
> 5.进行空间优化。

我们现在还是以`斐波那契问题`为例 ，一步一步实现这几个点。

**1. 确定问题的规模空间**

>假设输入为n，我们先考虑规模最小的问题，是1？然后最大规模，当然是n。从1到n问题的起点相同（都是1），终点不同（从1到n），很明显的一维线性，那么我们用一维空间保存每个规模的问题就行了，大小是n。dp[i]表示第i个斐波那契数。

**2. 确定问题的状态空间**

>对于这个问题，状态数是1，即当前数是这个数，就是这个数，没有任何伴随状态。不需要为状态再开多余的空间，但是如果无穷 >= 状态数 >= 2，就必须得再开一维数组了（后面会有这样的例子）。

**3. 更新状态**

>基本上与递归式是统一的，你怎么递归就怎么写状态转移，所以：
>
>dp[i] = dp[i - 1] + dp[i - 2]
>
>事实上，完整的写法是：
>
>dp\[i][0] =  dp\[i - 1][0] + dp\[i - 2][0]
>
>但是由于第二维表示状态的数组大小为1，所以可以不要了。

**4. 自底向上求解问题**

>第一部中说道，问题规模的增大是满足一维线性的，起点相同，终点不同，那我们按顺序遍历终点，并使用转移公式更新。
>
>```c++
>int dp(int n){
>  vector<int> dp(n + 1, 0);
>  dp[0] = 0, dp[1] = 1;
>  for(int i = 2; i <= n; ++i)
>    dp[i] = dp[i - 1] + dp[i - 2];
>  return dp[n];
>}
>```

**5.进行空间优化。**

>观察更新状态的条件：
>
>dp[i] = dp[i - 1] + dp[i - 2]
>
>我们每次只用带了前两个规模的子问题，那么我们完全没有必要把前三个和前四个等等的子问题继续保存，只需要使用两个变量滚动更新就行了。
>
>```c++
>int dp(int n){
>  int f1 = 0, f2 = 1;
>  int f3 = n == 0 ? 0 : 1;
>  for(int i = 2; i <= n; ++i){
>    f3 = f1 + f2;
>    f1 = f2;
>    f2 = f3;
>  }
>  return f3;
>}
>```

好了，我该说的说完了，我个人觉得，按照这套流程去解dp问题真的蛮有用的，现在我们就来用一个系列的问题练练手。

###买卖股票的最佳时机（简单）

>给定一个数组prices，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
>
>注意：不能在买入股票期卖出股票。

还是按步骤解题：

第一步，确定问题规模空间

首先，这个题还是典型的起点相同，终点不同问题，继续用长度为n的数组表示不同规模对应的解，dp[i]表示第i天的最大利益。

第二步，确定状态空间

买入或者卖出股票是一种状态，长度为2，dp\[i][0]（i时刻买入的最大利益）和dp\[i][1]（i时刻卖出的最大利益）。

第三步，状态转移公式很容易想到如下（事实上状态转移是dp问题中唯一的难点）：

**dp\[i][0] = max(dp\[i - 1][0], -prices[i ]);**

**dp\[i][1] = max(dp\[i - 1][1], dp\[i][0] + prices[i])**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size() + 1, vector<int>{INT_MIN, 0});
        for(int i = 1; i <= prices.size(); ++i) {
            dp[i][0] = max(dp[i - 1][0], -prices[i - 1]);
            dp[i][1] = max(dp[i - 1][1], dp[i][0] + prices[i - 1]);
        }
        return dp[prices.size()][1];
    }
};
```

第四步，进行空间优化，观察状态转移方程，当前规模问题的状态更新最多只用到了一个子问题，所以可以去掉第一维表示问题规模的数组，将第二维设计成滚动数组，由于第二维的大小size也是O(1)，所以可以用变量迭代替换滚动数组：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int stateBuy = INT_MIN, stateSell = 0;
        for(int i = 0; i < prices.size(); ++i) {
            stateBuy = max(stateBuy, -prices[i]);
            stateSell = max(stateSell, stateBuy + prices[i]);
        }
        return stateSell;
    }
};
```

### 买卖股票的最佳时机II（简单）

>还是原来的题目背景，这一次不限制只能进行一次买卖，而是可以进行无数次买卖，问最大利益。

不限次数的话，该问题的dp性质仍然存在，但同时也变成了一个具有贪心性质的问题，贪心问题在当前问题的解与子问题无关，只需要做一次贪心更新就行了。但是我们还是继续看dp的解法。与问题一相同，只不过状态转移变为如下：

**dp\[i][0] = max(dp\[i - 1][0],dp\[i - 1][1] - prices[i ]);**

**dp\[i][1] = max(dp\[i - 1][1], dp\[i - 1][0] + prices[i])**

**或dp\[i][1] = max(dp\[i - 1][1], dp\[i ][0] + prices[i])**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size() + 1, vector<int>{INT_MIN, 0});
        for(int i = 1; i <= prices.size(); ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i - 1]);
            dp[i][1] = max(dp[i - 1][1], dp[i][0] + prices[i - 1]);
        }
        return dp[prices.size()][1];
    }
};
```

同样的思路，进行空间优化，去掉第一维，然后用变量代替数组：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int stateBuy = INT_MIN, stateSell = 0;
        for(int i = 0; i < prices.size(); ++i) {
          	stateBuy = max(stateBuy, stateSell - prices[i]);
          	stateSell = max(stateSell, stateBuy + prices[i]);
        }
        return stateSell;
    }
};
```

###买卖股票的最佳时机III（困难）

>题目大意不变，这次我们只能进行两次买卖，还是问最大利益。

现在买卖次数变成2，大于等于2并且小于正无穷。所以我们要给原数组再增加一个长度为2的维度，dp\[i]\[0][0]就表示i时刻买入股票并且是第1次交易的情况。共有2×2=4中状态组合，所以状态更新公式也有四组：

**dp\[i]\[0][0] = max(dp\[i - 1]\[0][0], -prices[i ]);**

**dp\[i]\[1][0] = max(dp\[i - 1]\[1][0], dp\[i]\[0][0] + prices[i])**

**dp\[i]\[0][1] = max(dp\[i - 1]\[0][1], dp\[i]\[1][0] - prices[i]);**

**dp\[i]\[1][1] = max(dp\[i - 1]\[1][1], dp\[i]\[0][1] + prices[i])**

写出来是这样的：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<vector<int>>> dp(prices.size() + 1, {{INT_MIN, INT_MIN}, {0, 0}});
        for(int i = 1; i <= prices.size(); ++i) {
            dp[i][0][0] = max(dp[i - 1][0][0], -prices[i - 1]);
            dp[i][1][0] = max(dp[i - 1][1][0], dp[i][0][0] + prices[i - 1]);
            dp[i][0][1] = max(dp[i - 1][0][1], dp[i][1][0] - prices[i - 1]);
            dp[i][1][1] = max(dp[i - 1][1][1], dp[i][0][1] + prices[i - 1]);
        }
        return dp[prices.size()][1][1];
    }
};
```

然后进行空间优化，最多只用到了前一个子问题，并且只有4个状态，那么省去第一维，使用4个变量来表示4种状态，即`<first, second>`和`<buy, sell>`的笛卡尔组合。写出来是这样的：

```c++
class Solution___ {
public:
    int maxProfit(vector<int>& prices) {
        int firstBuy = INT_MIN, firstSell = 0;
        int secondBuy = INT_MIN, secondSell = 0;
        for(int item : prices) {
            firstBuy = max(firstBuy, -item);
            firstSell = max(firstSell, firstBuy + item);
            secondBuy = max(secondBuy, firstSell - item);
            secondSell = max(secondSell, secondBuy + item);
        }
        return secondSell;
    }
};
```

### 买卖股票的最佳时机 IV (困难)

>这是这个系列要说的最后一道题，剩余几道的解题模式基本相似，稍作变化就行了。题目大意不变，这次我们只能进行k次买卖，还是问最大利益。

这个问题和问题III是一个模式，只不过我们表示剩余次数这个状态的数组长度由2变成了k，总的状态组合由2\*2种变成了2\*k种，但是由于之前状态数与输入无关，现在与输入相关，所以使用循环来更新2k个状态：

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(k > prices.size() / 2)
            k = prices.size() / 2;
        if(prices.size() == 0 || k == 0) return 0;
        vector<vector<vector<int>>> dp(prices.size() + 1, {vector<int>(k, INT_MIN), vector<int>(k, 0)});
        for(int i = 1; i <= prices.size(); ++i)
            for(int j = 0; j < k; ++j) {
                dp[i][0][j] = max(dp[i - 1][0][j], (j > 0 ? dp[i][1][j - 1] : 0) - prices[i - 1]);
                dp[i][1][j] = max(dp[i - 1][1][j], dp[i][0][j] + prices[i - 1]);
            }
        return dp[prices.size()][1][k - 1];
    }
};
```

很明显第一维可以去掉，这样我们只用两个长度为k的数组滚动更新就可以啦，具体怎么做大家自己练习一下。

最后再提一下树型dp，面对树这种递归定义的结构，一般很难用迭代的方法构造问题规模，只能使用递归，先自顶向下，再自底向上。如果递归函数体中的某一个表达式中同时出现两个递归项，就一定会出现重复搜索，这时候就只能采用备忘录判重。否则，整个树的遍历就会形成一个天然的由小到大的问题结构，既覆盖了所有解空间，又不会出现重复搜索，某个节点的解会用到其子节点的解，我们在每层递归里定义相应的状态并作为返回值就行了。可以参考`leetcode 337`题的两种解法。






